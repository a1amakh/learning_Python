"""
----- 5.1 -----
"""

"""
Допишите программу так, чтобы она печатала на экран список, содержащий последовательность чисел 0,1,2,3,4,5,6,7,8,9 ?
"""
# print(list(range(10)))

"""
Теперь необходимо передать в функцию range параметры, чтобы получилась последовательность чисел от 12 до 34 включительно?
"""
# print(list(range(12, 35)))

"""
Теперь давайте добавим шаг. Необходимо сформировать последовательность 25, 33, 41, 49, 57 .... , 169
"""
# print(list(range(25, 170, 8)))

"""
Нам осталось поработать с убывающими последовательностями.
Сформируйте последовательность -11, -12, -13, -14 .... , -35
"""
# print(list(range(-11, -36, -1)))

"""
Еще одну
Сформируйте последовательность 10, 9, 8, 7, ... , 0
"""
# print(list(range(10, -1, -1)))

"""
И последняя последовательность 1000, 950, 900, 850, ... , 500
"""
# print(list(range(1000, 499, -50)))


"""
----- 5.2 -----
"""

"""
Программа принимает на вход натуральное число N. Ваша задача вывести на экран все числа от 1 до N каждое число на отдельной строке. 
"""
# n = int(input())
# for i in range(1, n + 1):
#     print(i)

"""
Напишите программу, которая выведет все элементы арифметической прогрессии от 0 до 500 включительно с шагом 5.
Каждый элемент выводится отдельно на своей строке в таком виде
"""
# for i in range(0, 501, 5):
#     print(i)

"""
Программа принимает на вход натуральное число N. 
Ваша задача вывести на экран все числа от N до 1 в сторону уменьшения каждое число на отдельной строке. 
"""
# n = int(input())
# for i in range(n, 0, -1):
#     print(i)

"""
«Надо было брать биткоин в 2012!» именно такую фразу ваша программа должна вывести на экран 13 раз
"""
# for i in range(13):
#     print('Надо было брать биткоин в 2012!')

"""
Повторение - мать учения 
Каждый, кто смотрел Симпсонов, помнит, что в начале любой серии Барт писал забавные фразы на доске.
Давайте и мы напишем подобную программу. На вход ей будет поступать фраза и затем количество раз, которое эту фразу нужно повторить.
"""
# line = input()
# count = int(input())
# for i in range(count):
#     print(line)

"""
Давайте вспомним задачу FizzBuzz
Напишите программу, которая считывает два натуральных числа a и b (гарантируется, что a<b), после чего для всех чисел от a до b включительно выводит:
    “Fizz”, если это число делится на 3;
    “Buzz”, если это число делится на 5;
    “FizzBuzz”, если выполнены оба предыдущих условия;
    само это число в остальных случаях.
Формат ввода:
Два числа a и b, каждое на отдельной строке.
Формат вывода:
Для всех чисел от a до b напечатайте по одной строке, соответствующей правилам, описанным в условии.
"""
# a = int(input())
# b = int(input())
# for i in range(a, b + 1):
#     if i % 3 == 0 and i % 5 != 0:
#         print('Fizz')
#     elif i % 5 == 0 and i % 3 != 0:
#         print('Buzz')
#     elif i % 3 == 0 and i % 5 == 0:
#         print('FizzBuzz')
#     else:
#         print(i)

"""
Квадрат и куб
Давайте составим сводную информацию о квадратах и кубах интервала чисел.
На вход программе подается два натуральных числа a и b (гарантируется, что a<b), после чего для каждого целого числа 
на интервале от a до b включительно необходимо вывести фразу следующего вида:
«Число {число}; его квадрат = {квадрат}; его куб = {куб}»
Кавычки выводить не нужно и пользуйтесь f-строкой.
Формат входных данных:
На вход программе подается два натуральных числа a и b, каждое на отдельной строке.
Формат выходных данных:
Программа должна вывести текст в соответствии с условием задачи.
"""
# a = int(input())
# b = int(input())
# for i in range(a, b + 1):
#     print(f'Число {i}; его квадрат = {i ** 2}; его куб = {i ** 3}')

"""
Кратные 3 или 5
Если перечислить все натуральные числа ниже 10, которые кратны 3 или 5, то получим 3, 5, 6 и 9. Сумма этих чисел 23.
Напишите программу, которая принимает натуральное число n и находит сумму всех чисел ниже переданного числа n, 
которые делятся на 3 или на 5.
"""
# n = int(input())
# s = 0
# for i in range(n):
#     if i % 3 == 0 or i % 5 == 0:
#         s += i
# print(s)

"""
Напишите программу, которая найдет сумму кубов натуральных чисел от 50 до 100 включительно
"""
# s = 0
# for i in range(50, 101):
#     s += i ** 3
# print(s)

"""
Стандартная задача на нахождения факториала. Факториал числа n! обозначается и находится по формуле 
n!=1∗2∗3∗...∗nn!=1∗2∗3∗...∗n
Значит, согласно этой формуле
4!=1∗2∗3∗4=244!=1∗2∗3∗4=24
5!=1∗2∗3∗4∗5=1205!=1∗2∗3∗4∗5=120
Но учитывайте,  что
1!=11!=1
0!=10!=1
"""
# n = int(input())
# mult = 1
# for i in range(n + 1):
#     if i == 0 or i == 1:
#         i = 1
#     mult *= i
# print(mult)

"""
Мишка и игра
Мишка — маленький белый медвежонок. А как известно, маленькие медвежата в свободное время любят играть в кости на шоколадки. 
Одним замечательным солнечным утром, гуляя по льдинам, Мишка встретил своего друга Криса, которому и предложил сыграть в эту занимательную игру.
Правила её очень просты: сначала определяется значение n — количество раундов игры. В очередном раунде каждый 
из игроков один раз бросает стандартный игральный кубик, на грани которого нанесены различные числа от 1 до 6. 
Игрок, выбросивший большее значение, становится победителем в раунде. В случае, если выпавшие значения равны, победа не засчитывается никому.
В самой же игре побеждает участник, выигравший в большем количестве раундов. Если же количества побед, заслуженных игроками, равны, то объявляется ничья.
Мишка ещё совсем маленький и плохо умеет вести счёт, а потому попросил Вас понаблюдать за ходом игры и сообщить ему результат.
Входные данные:
В первой строке входных данных содержится число n (1≤n≤100) — количество раундов игры.
Следующие n строк содержат описание раундов. В i-й из них содержится пара целых чисел mi и ci (1≤mi,ci≤6) — результаты 
бросков Мишки и Криса в i-ом раунде соответственно.
Выходные данные:
В случае победы Мишки в единственной строке выведите "Mishka" (без кавычек), а в случае победы Криса выведите "Chris" (без кавычек). 
Если же игра сведётся к ничьей, то выведите "Friendship is magic!^^" (без кавычек).
PS: генерировать случайные числа(пользоваться модулем random) вам не нужно, данные для игры уже готовы. 
Вам нужно только их считать,  и узнать кто же победил
"""
# n = int(input())
# result = 0
# for i in range(n):
#     m, c = map(int, input().split())
#     if m > c:
#         result += 1
#     elif m < c:
#         result -= 1
# if result == 0:
#     print('Friendship is magic!^^')
# elif result > 0:
#     print('Mishka')
# elif result < 0:
#     print('Chris')

"""
Найдите, в каких строках из введённых и в каком месте упоминается "рок", причем регистр букв не важен.
Вместо явного цикла прохода по строке в цикле используйте подходящий метод строки.
Формат ввода:
На первой строке вводится натуральное число N — количество строк.
Далее следуют N строк.
Формат вывода:
Для каждой строки, в которой есть сочетание символов «рок», нужно вывести (в порядке появления таких строк) номер этой 
строки (нумерация начинается с единицы) и номер символа, с которого начинается первое вхождение этой подстроки (нумерация символов также с единицы).
"""
# n = int(input())
# a = []
# for i in range(n):
#     a.append(input())
# for i in range(n):
#     if 'рок' in a[i].lower():
#         print(i + 1, (a[i].lower().find('рок')) + 1)

"""
Предположим, вы переписываете у друга рецепты в блокнотик, но вам не нравится "соль". Переписывайте без этого слова.
Формат ввода:
На первой строке вводится натуральное число N — количество пунктов рецепта.
Далее следуют N строк — пункты рецепта.
Формат вывода:
Одна строка — пункты рецепта, разделённые запятой и пробелом, без пунктов с упоминанием слова "соль" (то есть таких, 
в которых нет подстроки "соль" в нижнем регистре).
"""
# n = int(input())
# a = []
# for i in range(n):
#     a.append(input())
# for i in range(n):
#     if i == n - 1 and 'соль' not in a[i].lower():
#         print(a[i])
#     elif 'соль' not in a[i].lower():
#         print(a[i], end=', ')

"""
Слишком длинные слова
Иногда некоторые слова вроде «civilization» или «internationalization» настолько длинны, что их весьма утомительно писать много раз в каком либо тексте.
Будем считать слово слишком длинным, если его длина строго больше 10 символов. Все слишком длинные слова можно заменить специальной аббревиатурой.
Эта аббревиатура строится следующим образом: записывается первая и последняя буква слова, а между ними — количество букв 
между первой и последней буквой (в десятичной системе счисления и без ведущих нулей).
Таком образом, «civilization» запишется как «c10n», а «internationalization» как «i18n».
Вам предлагается автоматизировать процесс замены слов на аббревиатуры. При этом все слишком длинные слова должны быть 
заменены аббревиатурой, а слова, не являющиеся слишком длинными, должны остаться без изменений.
Входные данные:
В первой строке содержится целое число n (1≤n≤100). В каждой из последующих n строк содержится по одному слову. 
Все слова состоят из малых латинских букв и имеют длину от 1 до 100 символов.
Выходные данные:
Выведите n строк. В i строке должен находиться результат замены i-го слова из входных данных.
"""
# n = int(input())
# a = []
# for i in range(n):
#     a.append(input())
#     if len(a[i]) > 10:
#         a[i] = a[i][0] + str(len(a[i][1:-1])) + a[i][-1]
# for i in range(n):
#     print(a[i])


"""
----- 5.3 -----
"""

"""
Перед вами список numbers, состоящий из 100 целых чисел
Ваша задачи пройтись в цикле по элементам списка и вывести на экран каждый элемент на отдельной строке
"""
# numbers = [99, 50, -16, 9, 47, -62, 5, -64, -68, 85, 11, -20, 16, 96, -43, 46, -25, 33, 81, -30, 64, 66, -11, 60, 3, -5, -1,
#  -80, 49, -12, -86, -40, -98, -92, -91, -71, 56, -76, -30, -82, 17, -2, -64, 47, 22, -28, 40, 55, 54, -3, -58, -10,
#  -35, -15, -2, -60, 70, 50, -77, 83, -49, 42, 27, -58, -79, -2, -100, -42, -18, 38, 95, 9, 98, -89, -46, 96, 64,
#  -35, 41, 94, 1, -90, 29, 23, 39, -3, 11, -65, -64, 52, -69, 32, -14, -49, -28, -11, 85, -75, -6, 15]
#
# for i in numbers:
#     print(i)

"""
Перед вами список words, состоящий из 100 строк
Ваша задачи пройтись в цикле по элементам списка и вывести на экран только те элементы, длина которых больше 6.
Выводить каждый элемент нужно на отдельной строке в том же порядке, в котором слова расположены в списке words
"""
# words = ['require', 'build', 'head', 'land', 'dark', 'seat', 'have', 'five', 'particularly', 'focus', 'moment',
#            'visit', 'past', 'turn', 'bad', 'modern', 'once', 'future', 'pay', 'assume', 'himself', 'physical', 'chance',
#            'remember', 'better', 'former', 'believe', 'explain', 'reduce', 'whatever', 'theory', 'during', 'enough',
#            'wall', 'commercial', 'challenge', 'tell', 'actually', 'include', 'somebody', 'decade', 'by', 'better',
#            'would', 'five', 'cost', 'kitchen', 'our', 'affect', 'board', 'practice', 'full', 'instead', 'apply', 'good',
#            'past', 'clearly', 'special', 'both', 'analysis', 'peace', 'truth', 'cultural', 'light', 'answer', 'build',
#            'each', 'watch', 'buy', 'theory', 'pretty', 'expect', 'account', 'music', 'sell', 'newspaper', 'reach',
#            'fish', 'tax', 'employee', 'start', 'most', 'during', 'citizen', 'develop', 'carry', 'only', 'certainly',
#            'rock', 'economy', 'risk', 'later', 'one', 'body', 'star', 'they', 'choice', 'appear', 'return', 'sometimes']
#
# for i in words:
#     if len(i) > 6:
#         print(i)

"""
Перед вами список numbers, состоящий из 100 целых чисел
Ваша задачи пройтись в цикле по элементам списка и увеличить каждый в 2 раза.
В итоге изначальный список numbers  должен измениться
В качестве ответа распечатайте измененный список numbers
"""
# numbers = [-35, 68, -91, 23, -92, -82, -74, 32, 39, -30, -100, -29, 54, 26, 54, -45, 20, 53, -17, 68, -35, 11, 26, -17,
#            70, 89, -81, -4, 61, -45, 13, 63, -48, -66, -92, -15, -88, -87, -75, 44, -49, -81, 19, -33, -59, 85, -69, -60,
#            9, -98, 28, 11, 15, -35, -80, 5, -20, -52, -45, 26, 47, -16, 40, -14, -12, 15, 73, -16, 29, -98, 93, -77, 1,
#            85, 77, 73, 100, -71, 99, 39, 2, -38, 49, -31, 15, 43, 94, -39, -89, -46, -71, 39, -56, 41, -93, 4, -79, 48,
#            88, -51]
# n = len(numbers)
#
# for i in range(n):
#     numbers[i] *= 2
# print(numbers)

"""
Заполняем список
Ваша задача создать список из n строк. Программа сперва будет принимать натуральное число n, а затем n строк 
в каждой отдельной строке. В качестве ответа выведите получившийся список.
"""
# n = int(input())
# a = []
#
# for i in range(n):
#     a.append(input())
# print(a)

"""
Входные данные:
На первой строке вводится один символ — строчная буква.
На второй строке вводится предложение.
Выходные данные:
Нужно вывести список слов (словом считается часть предложения, окружённая символами пустого пространства), 
в которых присутствует введённая буква в любом регистре, в том же порядке, в каком они встречаются в предложении.
"""
# n = input()
# a = input().split(' ')
#
# for i in a:
#     if n.lower() in i.lower():
#         print(i)

"""
Линейный поиск
Линейный поиск, также известный как последовательный поиск, этот метод используется для поиска элемента в списке. 
Линейный поиск является одним из базовых алгоритмов, с которым вы должны познакомиться, изучая программирования. 
Суть алгоритма в следующем: вы должны проверять каждый элемент списка последовательно один за другим, пока не найдете 
интересующий вас элемент или пока не закончится весь список.
Входные данные:
Программа получает на вход в одной строке элементы списка - целые числа, разделенные пробелом. Количество элементов произвольное
И на следующей строке вводится одно число r - значение поиска
Выходные данные:
Ваша задача реализовать линейный алгоритм поиска введенного значения r. В случае успеха - выведите порядковый номер(индекс) 
первого найденного элемента в списке при условии, что индексация начинается с единицы. Если данный элемент отсутствует - необходимо вывести строку ErrorValue 
"""
# a = input().split(' ')
# r = int(input())
# n = len(a)
#
# for i in range(n):
#     if int(a[i]) == r:
#         print(i + 1)
#         break
# else:
#     print('ErrorValue')

"""
На вход программе поступает список из целых чисел. Ваша задача найти в данном списке наименьшее положительное значение. 
В случае, если положительных значений нет, выведите строку "Empty"
"""
# a = input().split()
# n = len(a)
# minimum = 99999
#
# for i in range(n):
#     if int(a[i]) < minimum and int(a[i]) > 0:
#         minimum = int(a[i])
# if minimum != 99999:
#     print(minimum)
# else:
#     print('Empty')

"""
Напишите программу, которая находит рекордное количество вхождений (не обязательно подряд) символа в строку.
Формат ввода:
Вводится одна строка.
Формат вывода:
Выводится одно целое число — максимальное количество раз, которое встречается какая-либо буква (без учёта регистра) 
или иной символ во введённой строке.
"""
# s = input()
# result = []
#
# for i in s:
#     count = 0
#     temp = i
#     for j in s:
#         if temp.lower() == j.lower():
#             count += 1
#     result.append(count)
#
# print(max(result))

"""
Делимость на 11
Для делимости числа на 11 необходимо, чтобы разность между суммой цифр, стоящих на четных местах, и суммой цифр, 
стоящих на нечетных местах, делилась на 11.
Требуется написать программу, которая проверит делимость заданного числа на 11.
Входные данные:
Программа получает на вход одно натуральное число N, делимость которого надо проверить (1 ≤ N ≤ 1010000).
Выходные данные:
Выведите “YES”, если число делится на 11, или “NO” иначе.
"""
# n = int(input())
# a = list(map(int, str(n)))
# temp = 0
# sum_even = 0 #Сумма четных
# sum_odd = 0 #Сумма нечетных
#
# for i in a:
#     temp += 1
#     if temp % 2 == 0:
#         sum_even += i
#     else:
#         sum_odd += i
# if (sum_even - sum_odd) % 11 == 0:
#     print('YES')
# else:
#     print('NO')

"""
На вход программе подается строка, состоящая из различных символов: буквы, цифры, знаки препинания и т.д.
Ваша задача определить сколько символов в данной строке являются цифрами и также найти сумму всех этих цифр. 
Например, в строке "Комната 1408" содержится 4 цифры и их сумма равна 13.
В качестве ответа необходимо через пробел вывести 2 числа - количество цифр в введенной строке и их сумму
"""
# n = input()
# a = []
# numbers = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']
# for i in n:
#     if i in numbers:
#         a.append(int(i))
# print(len(a), sum(a))

"""
Правильная скобочная последовательность
Одна из стандартных задач на программирование. Подумайте над способом ее решения, если не приходит ничего в голову, 
загляните в подсказку)
И так, у нас есть последовательность скобочных символов, состоящая только из символов ( и )
Ваша задача определить является ли введенная скобочная последовательность правильной.
Правильная скобочная последовательность (ПСП) называется строка, состоящая только символов "скобок", 
где каждой закрывающей скобке найдётся соответствующая открывающая. При этом учитывайте, что:
    Пустая последовательность является правильной.
    Если A – правильная скобочная последовательность, то (A) – правильные скобочные последовательности.
    Если A и B – правильные скобочные последовательности, то AB – правильная скобочная последовательность.
Если введенная строка является ПСП, выведите YES, в противном случае - NO.
"""
# n = input()
# left = 0 #Скобка (
# right = 0 #Скобка )
#
# for i in n:
#     if i == '(':
#         left += 1
#     if i == ')':
#         right += 1
# if left == right:
#     print('YES')
# else:
#     print('NO')

"""
Правильная скобочная последовательность 2
Наша программа принимает на вход последовательность скобочных символов. Ваша задача определить является ли введенная 
скобочная последовательность правильной.
Правильная скобочная последовательность (ПСП) называется строка, состоящая только из символов "скобки", где каждой 
закрывающей скобке найдётся соответствующая открывающая (причём того же типа). При этом учитывайте, что:
    Пустая последовательность является правильной.
    Если A – правильная скобочная последовательность, то (A), [A] и {A} – правильные скобочные последовательности.
    Если A и B – правильные скобочные последовательности, то AB – правильная скобочная последовательность.
Если введенная строка является ПСП, выведите YES, в противном случае - NO.
"""
# n = input()
# #Пусть у скобок будут типы: 1 тип - (), 2 тип - [], 3 тип - {}
# type_1 = ['(', ')']
# type_2 = ['[', ']']
# type_3 = ['{', '}']
# types = [] #Типы не закрытых скобок
# temp = 0
# left_1, left_2, left_3 = 0, 0, 0
# right_1, right_2, right_3 = 0, 0, 0
#
# if n == '':
#     print('Yes')
# else:
#     for i in n:
#         #Блок левых
#         if i == type_1[0]:
#             left_1 += 1
#             types.append(1)
#             temp = 1
#         elif i == type_2[0]:
#             left_2 += 1
#             types.append(2)
#             temp = 2
#         elif i == type_3[0]:
#             left_3 += 1
#             types.append(3)
#             temp = 3
#         else:
#             # Блок правых
#             if i == type_1[1] and (temp == 1 or temp == 0):
#                 right_1 += 1
#                 if 1 in types:
#                     types.remove(1)
#                 else:
#                     break
#                 temp = 0
#             elif i == type_2[1] and (temp == 2 or temp == 0):
#                 right_2 += 1
#                 if 2 in types:
#                     types.remove(2)
#                 else:
#                     break
#                 temp = 0
#             elif i == type_3[1] and (temp == 3 or temp == 0):
#                 right_3 += 1
#                 if 3 in types:
#                     types.remove(3)
#                 else:
#                     break
#                 temp = 0
#             else:
#                 break
#     if left_1 == right_1 and left_2 == right_2 and left_3 == right_3 and types == []:
#         print('YES')
#     else:
#         print('NO')


"""
----- 5.4 -----
"""

"""
Давайте на практике применим метод подсчета
На вход вашей программе поступает положительное целое число n, а ваша задача вывести в порядке возрастания все цифры, 
которые встречались в этом числе, и напротив каждого также необходимо вывести сколько раз данная цифра встречалась в числе n
"""
# n = int(input())
# a = list(map(int, str(n)))
# count = [0] * (max(a) + 1)
#
# for i in a:
#     count[i] += 1
# for i in range(len(count)):
#     if count[i] > 0:
#         print(i, count[i])

"""
Сортировка подсчетом
Как видно из названия задачи, вам необходимо отсортировать список, состоящий только из чисел в пределах от -100 до 100 
включительно, сортировкой подсчетом.
Программа получает на вход число n - количество элементов в списке, затем сами элементы списка
Вам необходимо вывести отсортированный список
P.S. не пользуйтесь встроенной функцией sorted или методом sort
"""
# n = int(input())
# a = list(map(int, input().split()))
# count = [0] * 201
#
# for i in a:
#     count[i + 100] += 1
# for i in range(201):
#     if count[i] > 0:
#         print((str(i - 100) + ' ') * count[i], end='')


"""
----- 5.5 -----
"""

"""
Найдите сумму всех четырехзначных чисел, сумма цифр каждого из которых равна 20.
"""
# sum = 0
#
# for n1 in range(1, 10):
#     for n2 in range(10):
#         for n3 in range(10):
#             for n4 in range(10):
#                 temp = n1 + n2 + n3 + n4
#                 if temp == 20:
#                     sum += int(str(n1) + str(n2) + str(n3) + str(n4))
# print(sum)

"""
В этой задаче вам предстоит построить лесенку из чисел. 
Программа принимает на вход целое положительное число n (n<=15) - количество уровней, ваша задача вывести n уровней, 
в каждом из которых стоят числа от 1 до значения уровня.
"""
# n = int(input())
#
# for i in range(n):
#     for j in range(i + 1):
#         print(j + 1, end=' ')
#     print()

"""
Постулат Бертрана
Постулат Бертрана (теорема Бертрана-Чебышева, теорема Чебышева) гласит, что для любого n > 1 найдется простое число p 
в интервале n < p < 2n. Такая гипотеза была выдвинута в 1845 году французским математиком Джозефем Бертраном 
(проверившим ее до n=3000000) и доказана в 1850 году Пафнутием Чебышевым. Рамануджан в 1920 году нашел более простое доказательство, 
а Эрдеш в 1932 – еще более простое.
Ваша задача состоит в том, чтобы решить несколько более общую задачу – а именно по числу n найти количество простых чисел p из интервала n < p < 2n.
Напомним, что число называется простым, если оно делится только само на себя и на единицу.
Входные данные:
Программа принимает на вход целое число n (2 ≤ n ≤ 50000).
Выходные данные:
Вам необходимо вывести на экран одно число – количество простых чисел p на интервале  n < p < 2n.
"""
# from math import sqrt
# n = int(input())
# count = 0
#
# for p in range(n + 1, n * 2):
#     i = 2
#     flag = True
#     while i <= sqrt(p):
#         if p % i == 0:
#             flag = False
#             break
#         i += 1
#     if flag:
#         count += 1
# print(count)

"""
Система уравнений
Фурик очень любит уроки математики, поэтому, в отличие от Рубика, он их не посещает. Но теперь Фурик хочет получить 
хорошую оценку по математике. Для этого Лариса Ивановна, учительница математики, дала ему новое задание. 
Фурик сразу же решил эту задачу, а вы сможете?
Задана система уравнений:
Нужно посчитать количество пар целых чисел (a,b) (0≤a,b), которые удовлетворяют системе.
Входные данные:
В единственной строке заданы два целых числа n,m (1≤n,m≤1000) — параметры системы. Числа в строке разделены пробелом.
Выходные данные:
В единственную строку выведите ответ на задачу.
"""
# n, m = map(int, input().split())
# count = 0
#
# for a in range(10):
#     for b in range(10):
#         if a ** 2 + b == n:
#             if a + b ** 2 == m:
#                 count += 1
# print(count)

"""
Напишите программу для построения горизонтальных столбчатых диаграмм с помощью символа звёздочки. 
Формат ввода:
Несколько натуральных чисел на одной строке.
Формат вывода:
Несколько чисел на одной строке.
"""
# a = list(map(int, input().split()))
#
# for i in range(len(a)):
#     for j in range(a[i]):
#         print('*', end='')
#     print()

"""
Вот мы с вами и добрались до легендарной сортировки пузырьком. 
Все просто, вам поступает число n - количество элементов в списке, и затем сам список.
Ваша задача отсортировать список по возрастанию при помощи пузырьковой сортировки, в случае если элементы соседние совпадают менять их ненужно.
В качестве ответа нужно вывести отсортированный список и какое количество раз пришлось переставлять элементы в процессе сортировки
"""
# n = int(input())
# a = list(map(int, input().split()))
# count = 0
#
# for i in range(n):
#     for j in range(n - 1):
#         if a[j] > a[j + 1]:
#             temp = a[j]
#             a[j] = a[j + 1]
#             a[j + 1] = temp
#             count += 1
# print(*a)
# print(count)

"""
Сортировка вставками
Это еще один вид сортировки, который реализуется при помощи вложенных циклов
Программа получает на вход число n - количество элементов в списке, и затем в следующей строке сам список.
Ваша задача отсортировать список по возрастанию при помощи сортировки вставками, в случае если элементы соседние совпадают менять их ненужно.
В качестве ответа нужно вывести отсортированный список.
"""
# n = int(input())
# a = list(map(int, input().split()))
#
# for i in range(n - 1):
#     while a[i + 1] <= a[i] and i > -1:
#         temp = a[i]
#         a[i] = a[i + 1]
#         a[i + 1] = temp
#         i -= 1
# print(*a)


"""
----- 5.6 -----
"""

"""
Вам нужно посчитать сумму элементов двумерного квадратного (NxN) списка, которые расположены на главной диагонали.
Под главной диагональю матрицы подразумевается диагональ, проведённая из левого верхнего угла в правый нижний.
Программа сперва принимает на вход число N (N<=15) - количество строк и столбцов в списке, а затем в N строках записаны элементы списка.
"""
# n = int(input())
# a = []
# s = 0
#
# for i in range(n):
#     b = list(map(int, input().split()))
#     a.append(b)
#
# for i in range(n):
#     for j in range(n):
#         if i == j:
#             s += a[i][j]
#
# print(s)

"""
Обход элементов матрицы - 1
Задана целочисленная квадратная матрица размером N x N. Необходимо обойти элементы этой матрицы сверху вниз слева направо 
и вывести элементы именно в таком порядке в виде таблицы. 
Программа принимает на вход натуральное число N – количество строк и столбцов матрицы. В каждой из последующих N строк 
записаны N целых чисел – элементы матрицы. Все числа во входных данных не превышают 100 по абсолютной величине.
"""
# n = int(input())
# a = []
# s = 0
#
# for i in range(n):
#     b = list(map(int, input().split()))
#     a.append(b)
#
# for i in range(n):
#     for j in range(n):
#         print(a[j][i], end=' ')
#     print()

"""
Обход элементов матрицы - 2
Задана целочисленная квадратная матрица размером N x N. Необходимо обойти элементы этой матрицы снизу вверх справо налево 
и вывести элементы именно в таком порядке в виде таблицы. 
Программа принимает на вход натуральное число N – количество строк и столбцов матрицы. В каждой из последующих N строк 
записаны N целых чисел – элементы матрицы. 
"""
# n = int(input())
# a = []
# s = 0
#
# for i in range(n):
#     b = list(map(int, input().split()))
#     a.append(b)
#
# for i in range(n - 1, -1, -1):
#     for j in range(n - 1, -1, -1):
#         print(a[j][i], end=' ')
#     print()

"""
Задана целочисленная матрица, состоящая из N строк и M столбцов. Необходимо обойти элементы этой матрицы cправо налево 
сверху вниз и вывести элементы именно в таком порядке в виде таблицы. 
Программа принимает на вход два натуральных числа N и M – количество строк и столбцов матрицы. В каждой из последующих 
N строк записаны M целых чисел – элементы матрицы.
"""
# n, m = map(int, input().split())
# a = []
# s = 0
#
# for i in range(n):
#     b = list(map(int, input().split()))
#     a.append(b)
#
# for i in range(n):
#     for j in range(m - 1, -1, -1):
#         print(a[i][j], end=' ')
#     print()

"""
Обход элементов матрицы - 4
Задана целочисленная матрица, состоящая из N строк и M столбцов. Необходимо обойти элементы этой матрицы слева направо 
снизу вверх и вывести элементы именно в таком порядке в виде таблицы. 
Программа принимает на вход два натуральных числа N и M – количество строк и столбцов матрицы. В каждой из последующих 
N строк записаны M целых чисел – элементы матрицы. 
"""
# n, m = map(int, input().split())
# a = []
# s = 0
#
# for i in range(n):
#     b = list(map(int, input().split()))
#     a.append(b)
#
# for i in range(n - 1, -1, -1):
#     for j in range(m):
#         print(a[i][j], end=' ')
#     print()

"""
A. Красивая матрица 
Перед Вами матрица размера 5×5, состоящая из 24-x нулей и единственной единицы. Строки матрицы пронумеруем числами 
от 1 до 5 сверху вниз, столбцы матрицы пронумеруем числами от 1 до 5 слева направо. За один ход разрешается применить 
к матрице одно из двух следующих преобразований:
    Поменять местами две соседние строки матрицы, то есть строки с номерами i и i+1 для некоторого целого i (1≤i<5).
    Поменять местами два соседних столбца матрицы, то есть столбцы с номерами j и j+1 для некоторого целого j (1≤j<5).
Вы считаете, что матрица будет выглядеть красиво, если единственная единица этой матрицы будет находиться в ее центре 
(в клетке, которая находится на пересечении третьей строки и третьего столбца). Посчитайте, какое минимальное количество 
ходов потребуется, чтобы сделать матрицу красивой.
Входные данные:
Входные данные состоят из пяти строк, в каждой из которых записаны пять целых чисел: j-ое число в i-ой строке входных 
данных обозначает элемент матрицы, стоящий на пересечении i-ой строки и j-ого столбца. Гарантируется, что матрица 
состоит из 24-x нулей и единственной единицы.
Выходные данные:
Выведите единственное целое число — минимальное количество действий, которое требуется, чтобы сделать матрицу красивой.
"""
# a = []
#
# for i in range(5):
#     b = list(map(int, input().split()))
#     a.append(b)
#
# for i in range(5):
#     for j in range(5):
#         if a[i][j] == 1:
#             temp = (abs(3 - (i + 1))) + (abs(3 - (j + 1)))
#
# print(temp)

"""
Сумма строк и столбцов двумерного массива 
Задан целочисленный двумерный массив, состоящий из N строк и M столбцов. Требуется вычислить сумму элементов в каждой 
строке и в каждом столбце.
Программа получает на вход два натуральных числа N и M – количество строк и столбцов двумерного массива. 
В каждой из последующих N строк записаны M целых чисел – элементы массива. Все числа во входных данных не превышают 1000 
по абсолютной величине.
В первой строке вам необходимо вывести N чисел – суммы элементов массива для каждой строки в отдельности.
Во второй строке в аналогичном формате выведите M чисел – суммы элементов для каждого столбца.
"""
# n, m = map(int, input().split())
# a = []
# s1 = []
# s2 = []
#
# for i in range(n):
#     b = list(map(int, input().split()))
#     a.append(b)
#
# for i in range(n):
#     temp = 0
#     for j in range(m):
#         temp += a[i][j]
#     s1.append(temp)
#
# for j in range(m):
#     temp = 0
#     for i in range(n):
#         temp += a[i][j]
#     s2.append(temp)
#
# print(*s1)
# print(*s2)

"""
Симметричная ли матрица? 
Проверьте, является ли двумерный массив симметричным относительно главной диагонали. Главная диагональ — та, которая 
идёт из левого верхнего угла двумерного массива в правый нижний.
Входные данные:
Программа получает на вход число n<100, являющееся числом строк и столбцов в массиве. Далее во входном потоке идет n строк 
по n чисел, являющихся элементами массива.
Выходные данные:
Программа должна выводить слово Yes для симметричного массива и слово No для несимметричного.
"""
# n = int(input())
# a = []
# flag = True
#
# for i in range(n):
#     b = list(map(int, input().split()))
#     a.append(b)
#
# for i in range(n):
#     for j in range(n):
#         if a[i][j] != a[j][i]:
#             flag = False
#
# if flag:
#     print('Yes')
# else:
#     print('No')

"""
Состязания
В метании молота состязается n спортcменов. Каждый из них сделал m бросков. Победителем считается тот спортсмен, 
у которого сумма результатов по всем броскам максимальна.
Если перенумеровать спортсменов числами от 0 до n-1, а попытки каждого из них – от 0 до m-1, то на вход программа получает 
массив A[n][m], состоящий из неотрицательных целых чисел. Программа должна определить максимальную сумму чисел в одной строке 
и вывести на экран эту сумму и номер строки, для которой достигается эта сумма.
Входные данные:
Программа получает на вход два числа n и m, являющиеся числом строк и столбцов в массиве. Далее во входном потоке 
идет n строк по m чисел, являющихся элементами массива.
Выходные данные:
Программа должна вывести  2 числа: сумму и номер строки, для которой эта сумма достигается. Если таких строк несколько, 
то выводится номер наименьшей из них. Не забудьте, что нумерация строк (спортсменов) начинается с 0.
"""
# n, m = map(int, input().split())
# a = []
# result = []
#
# for i in range(n):
#     b = list(map(int, input().split()))
#     a.append(b)
#
# for i in range(n):
#     s = 0
#     for j in range(m):
#         s += a[i][j]
#     result.append(s)
#
# print(max(result))
# print(result.index(max(result)))

"""
Состязания - 2
В метании молота состязается n спортcменов. Каждый из них сделал m бросков. Победителем соревнований объявляется тот 
спортсмен, у которого максимален наилучший результат по всем броскам. Таким образом, программа должна найти значение 
максимального элемента в данном массиве, а также его индексы (то есть номер спортсмена и номер попытки).
Входные данные:
Программа получает на вход два числа n и m, являющиеся числом строк и столбцов в массиве. Далее во входном потоке 
идет n строк по m чисел, являющихся элементами массива.
Выходные данные:
Программа выводит значение максимального элемента, затем номер строки и номер столбца, в котором он встречается.
Если в массиве несколько максимальных элементов, то нужно вывести минимальный номер строки, в которой встречается 
такой элемент, а если в этой строке таких элементов несколько, то нужно вывести минимальный номер столбца. Не забудьте,
 что все строки и столбцы нумеруются с 0.
"""
# n, m = map(int, input().split())
# a = []
# result = 0
# temp = [0, 0]
#
# for i in range(n):
#     b = list(map(int, input().split()))
#     a.append(b)
#
# for i in range(n):
#     for j in range(m):
#         if a[i][j] > result:
#             result = a[i][j]
#             temp[0] = i
#             temp[1] = j
#
# print(result)
# print(*temp)

"""
Состязания - 3
В метании молота состязается n спортcменов. Каждый из них сделал m бросков. Побеждает спортсмен, у которого максимален 
наилучший бросок. Если таких несколько, то из них побеждает тот, у которого наилучшая сумма результатов по всем попыткам.
Если и таких несколько, победителем считается спортсмен с минимальным номером. Определите номер победителя соревнований.
Входные данные:
Программа получает на вход два числа n и m, являющиеся числом строк и столбцов в массиве. Далее во входном потоке 
идет n строк по m чисел, являющихся элементами массива.
Выходные данные:
Программа должна вывести одно число - номер победителя соревнований. Не забудьте, что  строки  (спортсмены) нумеруются с 0.
"""
# n, m = map(int, input().split())
# a = []
# h =[0]
# temp = 0
# result = 0
#
# for i in range(n): #Ввод матрицы
#     b = list(map(int, input().split()))
#     a.append(b)
#
# for i in range(n): #Поиск максимальных значений в матрице
#     for j in range(m):
#         if a[i][j] > temp:
#             temp = a[i][j] #Это временное максимальное значение
#             h.clear() #Очистка списка, если нашлось максимальное значение
#             h.append(i) #Добавление в список, если нашлось максимальное значение
#         elif a[i][j] == temp:
#             h.append(i) #Добавление в список, если текущее значение == максимальному
#
# if len(h) > 1: #Проверка на максимальную сумму значений бросков спортсменов, если наилучшие броски совпали
#     temp = [] #Временный массив сумм
#     for i in h:
#         temp.append(sum(a[i])) #Добавление таковой суммы
#     result = h[temp.index(max(temp))] #Присвоение индекса спортсмена с максимальной суммой значений бросков
# else:
#     result = h[0]
#
# print(result)

"""
Состязания - 4
В метании молота состязается n спортcменов. Каждый из них сделал m бросков. Победитель определяется по лучшему результату. 
Определите количество участников состязаний, которые разделили первое место, то есть определите количество строк в массиве, 
которые содержат значение, равное наибольшему.
Входные данные:
Программа получает на вход два числа n и m, являющиеся числом строк и столбцов в массиве. Далее во входном потоке 
идет n строк по m чисел, являющихся элементами массива.
Выходные данные:
Программа должна вывести  одно число - количество победителей соревнования.
"""
# n, m = map(int, input().split())
# a = []
# temp = 0
# result = []
#
# for i in range(n):
#     b = list(map(int, input().split()))
#     a.append(b)
#
# for i in range(n):
#     for j in range(m):
#         if a[i][j] > temp:
#             temp = a[i][j]
#             result = []
#             result.append(i)
#         elif a[i][j] == temp:
#             result.append(i)
# result = list(set(result)) #Для удаления повторяющихся элементов списка
#
# print(len(result))

"""
Симпатичный узор
На днях Иван у себя в прихожей выложил кафель, состоящий из квадратных черных и белых плиток. Прихожая Ивана имеет 
квадратную форму 4х4, вмещающую 16 плиток. Теперь Иван переживает, что узор из плиток, который у него получился, может 
быть не симпатичным. С точки зрения дизайна симпатичным узором считается тот, который не содержит в себе квадрата 2х2, 
состоящего из плиток одного цвета.
По заданному расположению плиток в прихожей Ивана требуется определить: является ли выполненный узор симпатичным.
Программе поступает на вход 4 строки по 4 символа «W» или «B» в каждой, описывающие узор из плиток. 
Символ «W» обозначает плитку белого цвета, а «B» - черного.
Ваша задача вывести «Yes», если узор является симпатичным и «No» в противном случае.
"""
# a = []
# flag = True
#
# for i in range(4):
#     b = input()
#     a.append(b)
#
# for i in range(3):
#     if flag == False:
#         break
#     for j in range(3):
#         if a[i][j] == a[i][j + 1]:
#             if a[i][j] == a[i + 1][j] == a[i + 1][j + 1]:
#                 flag = False
#
# if flag:
#     print('Yes')
# else:
#     print('No')

"""
Миша и негатив
Миша уже научился хорошо фотографировать и недавно увлекся программированием. Первая программа, которую он написал,
позволяет формировать негатив бинарного черно-белого изображения.
Бинарное черно-белое изображение – это прямоугольник, состоящий из пикселей, каждый из которых может быть либо черным, 
либо белым. Негатив такого изображения получается путем замены каждого черного пикселя на белый, а каждого белого 
пикселя – на черный.
Миша, как начинающий программист, написал свою программу с ошибкой, поэтому в результате ее исполнения мог получаться 
некорректный негатив. Для того чтобы оценить уровень несоответствия получаемого негатива исходному изображению, 
Миша начал тестировать свою программу.
В качестве входных данных он использовал исходные изображения. Сформированные программой негативы он начал тщательно 
анализировать, каждый раз определяя число пикселей негатива, которые получены с ошибкой.
Требуется написать программу, которая в качестве входных данных использует исходное бинарное черно-белое изображение и 
полученный Мишиной программой негатив, и на основе этого определяет количество пикселей, в которых допущена ошибка.
Программа сперва считывает числа n и m (1 ≤ n, m ≤ 100) – высоту и ширину исходного изображения (в пикселях). 
Последующие n строк содержат описание исходного изображения. Каждая строка состоит из m символов «B» и «W». 
Символ «B» соответствует черному пикселю, а символ «W» – белому. Далее следует пустая строка, а после нее – описание 
выведенного Мишиной программой изображения в том же формате, что и исходное изображение.
Необходимо вывести на экран число пикселей негатива, которые неправильно сформированы Мишиной программой.
"""
# a = []
# b = []
# count = 0
#
# #Блок ввода значений
# n, m = map(int, input().split())
#
# for i in range(n):
#     temp = input()
#     a.append(temp)
#     temp = ''
#
# input()
#
# for i in range(n):
#     temp = input()
#     b.append(temp)
#     temp = ''
#
# #Блок решения
# for i in range(n):
#     for j in range(m):
#         if a[i][j] == b[i][j]:
#             count += 1
#
# #Блок вывода
# print(count)

"""
A. Таблица умножения
Рассмотрим таблицу из n строк и n столбцов. Известно, что в клетке, образованной пересечением i-й строки и j-го столбца, 
записано число i×j. Строки и столбцы нумеруются с единицы.
Дано целое положительное число x. Требуется посчитать количество клеток таблицы, в которых находится число x.
Входные данные:
В единственной строке находятся числа n и x (1≤n≤10^5, 1≤x≤10^9) — размер таблицы и число, которое мы ищем в таблице.
Выходные данные:
Выведите единственное число: количество раз, которое число x встречается в таблице.
"""
# a = []
# count = 0
#
# #Блок ввода значений
# n, x = map(int, input().split())
#
# for i in range(n):
#     a.append([0] * n)
#
# #Блок решения
# for i in range(1, n + 1): #Заполняем матрицу значениями i * j и заодно проверяем
#     for j in range(1, n + 1):
#         a[i - 1][j - 1] = i * j
#         if i * j == x:
#             count += 1
#
# #Блок вывода
# print(count)


"""
----- 5.7 -----
"""

"""
A. Матчи
Манао работает на спортивном телевидении. Он долгое время наблюдал за футбольными матчами чемпионата одной страны и 
начал замечать разные закономерности. Например, у каждой команды есть две формы: домашняя и выездная. 
Когда команда проводит матч на своем стадионе, футболисты надевают домашнюю форму, а когда на чужом — выездную. 
Единственное исключение из этого правила — когда цвет домашней формы принимающей команды совпадает с цветом формы гостей. 
В таком случае домашняя команда облачается в свою выездную форму. Цвета домашней и выездной формы для каждой команды различны.
В чемпионате страны участвует n команд и он состоит из n·(n-1) матчей: каждая из команд принимает каждую другую команду 
на своем стадионе. Манао задумался, а сколько раз в течение одного чемпионата случится, что команда, играющая на своем 
стадионе, оденет выездную форму? Обратите внимание, что для подсчета этого количества порядок матчей не играет никакого значения.
Вам даны цвета домашней и выездной формы каждой команды. Для удобства эти цвета пронумерованы целыми числами таким образом, 
что никакие два разных цвета не имеют одинаковый номер. Помогите Манао найти ответ на его вопрос.
Входные данные:
В первой строке содержится целое число n (2≤n≤30). В каждой из следующих n строк записана пара разделенных одним пробелом 
различных целых чисел hi, ai (1≤hi,ai≤100) — номер цвета домашней и выездной форм i-ой команды соответственно.
Выходные данные:
В единственной строке выведите количество матчей, в которых домашняя команда выступит в выездной форме.
"""
# a = []
# count = 0
#
# #Блок ввода значений
# n = int(input())
#
# for i in range(n):
#     temp = list(map(int, input().split()))
#     a.append(temp)
#
# #Блок решения
# for i in range(n): #Перебор 1-го столбца
#     for j in range(n): #Перебор 2-го столбца
#         if a[i][0] == a[j][1]:
#             count += 1
#
# #Блок вывода
# print(count)

"""
Морской бой - 2
«Морской бой» - игра для двух участников, в которой игроки по очереди называют координаты на неизвестной им карте соперника. 
Если у соперника по этим координатам имеется корабль, то корабль или его часть «топится», а попавший получает право сделать 
еще один ход. Цель игрока - первым поразить все корабли противника.
«Морской бой» очень популярен среди учеников одной физико-математической школы. Ребята очень любят в него играть на переменах. 
Вот и сейчас ученики Иннокентий и Емельян начали новую партию.
Правила, по которым ребята расставляют корабли перед началом партии, несколько отличаются от классических. Во-первых, 
игра происходит на поле размером N×M, а не 10×10. Во-вторых, число кораблей, их размер и форма выбираются ребятами перед 
партией - так играть намного интереснее.
Емельян уже расставил все свои корабли, кроме одного однопалубного. Такой корабль занимает ровно одну клетку.
Задана расстановка кораблей Емельяна. Найдите число способов поставить оставшийся однопалубный корабль. При этом учитывайте, 
что по правилам его можно ставить только в ту клетку, все соседние с которой не заняты. В этой задаче соседними считаются 
клетки, имеющие общую сторону.
Программа считывает два числа: N и M (1 ≤ N, M ≤ 100). Последующие N строк описывают игровое поле - каждая из них 
содержит M символов. Символом «.» (точка) обозначена свободная клетка, символом «*» (звездочка) - занятая кораблем.
Необходимо вывести на экран ответ на задачу
"""
# a = []
# count = 0
#
# #Блок ввода значений
# n, m = map(int, input().split())
#
# for i in range(n):
#     temp = input()
#     a.append(temp)
#
# #Блок решения
# for i in range(n):
#     for j in range(m):
#         if a[i][j] == '.':
#             if i == 0: #Верхняя граница
#                 if j == 0:
#                     if a[i + 1][j] != '*' and a[i][j + 1] != '*':
#                         count += 1
#                 elif j == m - 1:
#                     if a[i + 1][j] != '*' and a[i][j - 1] != '*':
#                         count += 1
#                 else:
#                     if a[i + 1][j] != '*' and a[i][j + 1] != '*' and a[i][j - 1] != '*':
#                         count += 1
#             elif i == n - 1: #Нижняя граница
#                 if j == 0:
#                     if a[i - 1][j] != '*' and a[i][j + 1] != '*':
#                         count += 1
#                 elif j == m - 1:
#                     if a[i - 1][j] != '*' and a[i][j - 1] != '*':
#                         count += 1
#                 else:
#                     if a[i - 1][j] != '*' and a[i][j + 1] != '*' and a[i][j - 1] != '*':
#                         count += 1
#             else: #Все остальное
#                 if j == 0:
#                     if a[i + 1][j] != '*' and a[i - 1][j] != '*' and a[i][j + 1] != '*':
#                         count += 1
#                 elif j == m - 1:
#                     if a[i + 1][j] != '*' and a[i - 1][j] != '*' and a[i][j - 1] != '*':
#                         count += 1
#                 else:
#                     if a[i + 1][j] != '*' and a[i - 1][j] != '*' and a[i][j + 1] != '*' and a[i][j - 1] != '*':
#                         count += 1
#
# #Блок вывода
# print(count)

"""
Заполнение змейкой
Даны числа n и m. Создайте массив A[n][m] и заполните его змейкой (см. пример).
Входные данные:
Программа получает на вход два числа n и m.
Выходные данные:
Программа должна вывести  полученный массив, при этом между числами может быть любое количество пробелов.
"""
# a = []
# number = 0
#
# #Блок ввода значений
# n, m = map(int, input().split())
#
# #Блок решения
# for i in range(n):
#     temp = []
#     for j in range(m):
#         temp.append(number)
#         number += 1
#     if i % 2 != 0:
#         temp.sort(reverse=True)
#     a.append(temp)
#
# #Блок вывода
# for i in a:
#     for j in i:
#         print(j, end=' ')
#     print()

"""
A. Фотографии Брейна
Маленького, но очень смелого мышонка Брейна не взяли в летнюю школу юных злодеев. Он расстроился и решил отодвинуть свои 
планы по захвату мира, а вместо этого податься в фотографы.
Как вам наверняка известно, самые крутые фотографии получаются на пленку (ведь тогда в хештегах можно указать #пленка).
Брейн наснимал очень много красочных фотографий на цветную и черно-белую пленки. Затем проявил и перевел их в цифровой вид. 
Но вот незадача! Теперь цветные и черно-белые фотографии лежат в одной папке, и, чтобы их рассортировать, нужно потратить не один час!
Так как Брейн теперь фотограф, а не программист, он просит вас помочь ему для одной фотографии определить, цветная она или черно-белая.
Фотография представляет собой матрицу размера n×m, в каждой ячейке которой хранится символ, обозначающий цвет соответствующего 
пикселя. Всего существует 6 цветов:
    'C' (cyan) — голубой
    'M' (magenta) — пурпурный
    'Y' (yellow) — желтый
    'W' (white) — белый
    'G' (grey) — серый
    'B' (black) — черный
Фотографию можно считать черно-белой, если в ней есть только белый, серый или черный цвет. Если же присутствует хоть 
один пиксель голубого, пурпурного или желтого цвета, она цветная.
Входные данные:
В первой строке содержится два целых числа n и m (1≤n,m≤100) — количество строк и столбцов в матрице пикселей фотографии соответственно.
Далее следуют n строк, описывающих строки матрицы. Каждая из них состоит из m разделенных пробелом символов, описывающих 
цвета пикселей в строке. Каждый из символов в строке является одним из символов 'C', 'M', 'Y', 'W', 'G' или 'B'.
Выходные данные:
В единственной строчке выведите «#Black&White» (без кавычек), если фотография черно-белая, и «#Color» (без кавычек), если цветная.
"""
# a = []
# flag = True
#
# #Блок ввода значений
# n, m = map(int, input().split())
#
# for i in range(n):
#     temp = input()
#     a.append(temp)
#
# #Блок решения
# for i in range(n):
#     if flag == False:
#         break
#     for j in range(m):
#         if a[i][j] == 'Y' or a[i][j] == 'M' or a[i][j] == 'C':
#             flag = False
#             break
#
# #Блок вывода
# if flag:
#     print('#Black&White')
# else:
#     print('#Color')

"""
Спираль
Требуется вывести квадрат, состоящий из N×N клеток, заполненных числами от 1 до N2 по спирали (см. примеры).
Входные данные:
Программа получает на вход одно число n.
Выходные данные:
Программа должна вывести матрицу, заполненную числами от 1 до N2 по спирали, при этом между числами может быть любое 
количество пробелов. Не допускается начинать спираль в ином, кроме верхнего левого, углу, закручивать спираль против 
часовой стрелки или изнутри наружу.
"""
# a = []
# number = 1
# temp = 0
#
# #Блок ввода значений
# n = int(input())
#
# for i in range(n): #Заполняем 0 для удобства
#     a.append([0] * n)
#
# #Блок решения
# for j in range(n): #Я не понимаю, но тут явно неправильный способ задания цикличности прохода, но оно работает
#     for i in range(temp, n - temp): #Верхняя строка
#         a[temp][i] = number
#         number += 1
#     for i in range(temp + 1, n - temp): #Правый столбик
#         a[i][n - temp - 1] = number
#         number += 1
#     for i in range(n - temp - 2, temp - 1, - 1): #Нижняя строка
#         a[n - temp - 1][i] = number
#         number += 1
#     for i in range(n - temp - 2, temp, -1): #Левый столбик
#         a[i][temp] = number
#         number += 1
#     temp += 1 #Смещение после прохода
#
# #Блок вывода
# for i in a:
#     for j in i:
#         print(j, end=' ')
#     print()

"""
A. Тортминатор
Дан прямоугольный торт, который имеет вид таблицы размером r×c. Каждая ячейка таблицы содержит либо гадкую клубничку, 
либо является пустой. Например, торт размера 3×4 может выглядеть так:
Тортминатор намерен съесть этот торт! Каждый раз, когда он ест, он выбирает строку или столбец, не содержащие гадкой клубнички, 
а содержащие по крайней мере одну несъеденную ячейку торта. Затем Тортминатор поедает все выбранные им ячейки торта. 
Тортминатор может есть сколько угодно раз.
Пожалуйста, выведите максимальное количество ячеек, которые может съесть Тортминатор.
Входные данные:
Первая строка содержит два целых числа r и c (2≤r,c≤10), обозначающих количество строк и количество столбцов в торте. 
Следующие r строк содержат по c символов — j-ый символ i-ой строки обозначает содержимое ячейки в строке i и столбце j, 
и имеет одно из следующих значений:
    символ '.' обозначает ячейку торта без гадкой клубнички;
    символ 'S' обозначает ячейку торта с гадкой клубничкой.
Выходные данные:
Выведите максимальное количество ячеек торта, которые может съесть тортминатор.
"""
# a = []
# count = []
#
# #Блок ввода значений
# n, m = map(int, input().split())
#
# for i in range(n):
#     temp = input()
#     a.append(temp)
#
# #Блок решения
# for i in range(n): #Обход строк
#     flag = True
#     for j in range(m):
#         if a[i][j] == 'S':
#             flag = False
#     if flag == True: #Если в строке нет S
#         for y in range(m): #Перебираем координаты каждой точки и добавляем в итоговый массив
#             if [i, y] not in count:
#                     count.append([i, y])
#
# for j in range(m): #Обход столбцов
#     flag = True
#     for i in range(n):
#         if a[i][j] == 'S':
#             flag = False
#     if flag == True: #Если в столбце нет S
#         for y in range(n): #Перебираем координаты каждой точки и добавляем в итоговый массив
#             if [y, j] not in count:
#                 count.append([y, j])
#
# #Блок вывода
# print(len(count)) #Подсчет длины массива == Количество ячеек торта для тортминатора


"""
----- 5.8 -----
"""

"""
Треугольник Паскаля Python. Коэффициенты для Бинома Ньютона.
"""
# a = []
#
# #Блок ввода значений
# n = int(input())
#
# for i in range(n + 1):
#     a.append([1] + [0] * n)
#
# #Блок решения
# for i in range(1, n + 1):
#     for j in range(1, i + 1):
#         a[i][j] = a[i - 1][j] + a[i - 1][j - 1]
#
# #Блок вывода
# for i in a:
#     for j in i:
#         print(j, end=' ')
#     print()


"""
----- 5.9 -----
"""

"""

"""
